# 문제1
# 백준 2525번 : 오븐시계 (https://www.acmicpc.net/problem/2525)

# 입력
# 첫째 줄에는 현재 시각이 나온다. 
# 현재 시각은 시 A (0 ≤ A ≤ 23) 와 분 B (0 ≤ B ≤ 59)가 정수로 빈칸을 사이에 두고 순서대로 주어진다. 
# 두 번째 줄에는 요리하는 데 필요한 시간 C (0 ≤ C ≤ 1,000)가 분 단위로 주어진다. 

# 출력
# 첫째 줄에 종료되는 시각의 시와 분을 공백을 사이에 두고 출력한다. 
# (단, 시는 0부터 23까지의 정수, 분은 0부터 59까지의 정수이다. 디지털 시계는 23시 59분에서 1분이 지나면 0시 0분이 된다.)

A, B = map(int, input().split())
C = int(input())

if B + C > 59:               # B(현재 분)에 C(필요한 시간)를 추가했을때 59가 넘는다면,
    A += (B+C)//60           # A(현재 시)에 B+C의 몫을 더함
    B = (B+C)%60             # B(현재 분)는 B+C의 나머지가 됨

    if A > 23:               # 위 조건문을 계산했을때 만약 A가 23을 넘어간다면,
        A = A-24             # A = A-24로 바꿈
else:                        # 맨 처음 조건문에 해당하지 않는다면(B+C가 59가 넘지 않는다면)
    B = B+C                  # B만 B+C로 바꿔줌

print(A, B)    


# 문제2
# 백준 2798번 : 블랙잭 (https://www.acmicpc.net/problem/2798)
# 콤비네이션 사용해보기

# 입력
# 첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 
# 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다.
# 합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.

# 출력
# 첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.

N, M = map(int, input().split())
cards = list(map(int, input().split()))
max_total = 0                                    # 최대 합 0으로 설정해놓기

for i in range(N-2):
    for j in range(i+1, N-1):
        for k in range(j+1, N):                  # 완전탐색 반복문 돌리기
            total = cards[i]+cards[j]+cards[k]   

            if max_total < total <= M:   # 카드3개의 합(total)이 최대합(max_total)보다 크고 M보다 작거나 같다면
                max_total = total        # max_total은 total

print(max_total)


# 문제3
# 백준 9076번 : 점수 집계 (https://www.acmicpc.net/problem/9076)

# 문제
# 한국 체조협회에서는 심판의 오심을 막기 위하여 점수 집계 시스템을 고치기로 하였다. 
# 이전에는 5명의 심판이 1점부터 10점까지 정수의 점수를 주면 최고점과 최저점을 하나씩 제외한 점수의 합을 총점으로 하였다. 
# 이를 보완하기 위해서 최고점과 최저점을 뺀 나머지 3명 점수의 최고점과 최저점의 차이가 4점 이상 나게 되면 점수 조정을 거쳐서 
# 다시 점수를 매기려고 한다. 
# 점수를 집계하여 총점을 계산하거나, 점수 조정을 거쳐서 다시 점수를 매기려고 하는 경우에는 총점 대신 
# KIN(Keep In Negotiation)을 출력하는 프로그램을 작성하시오.

# 입력
# 입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 10)가 주어진다. 
# 각 테스트 케이스는 한 줄에 다섯 심판이 준 점수 다섯 개의 정수 Ni(1 ≤ Ni ≤ 10, i = 1, 2, ..., 5)가 
# 하나의 공백을 사이에 두고 주어진다.

# 출력
# 각 테스트 케이스에 대해서 총점을 한 줄씩 출력한다. 
# 만일 점수 조정을 거쳐서 다시 점수를 매기려고 하는 경우에는 총점 대신 KIN을 출력한다.

T = int(input())

for _ in range(T):                            # 테스트케이스만큼 반복문 돌리기
    score = list(map(int, input().split()))   # 점수를 리스트로 입력받기
    score.remove(max(score))                  # 점수리스트에서 최대값 제거
    score.remove(min(score))                  # 점수리스트에서 최소값 제거

    if max(score)-min(score) < 4:             # 남아있는 리스트에서 최대값 - 최소값이 4 미만이라면,
        print(sum(score))                     # 리스트의 총합 출력
    else:
        print('KIN')                          # 그게 아니라면(최대값-최소값이 4이상이라면), 'KIN' 출력


# 문제4
# 백준 1526번 : 가장 큰 금민수 (https://www.acmicpc.net/problem/1526)
# 이 문제와 문제5번 모두 while문으로 풀었는데, 잘 안됐다. 그래서 다시 자릿수로 풀려다보니 막혔다...
# 팀원분들 풀이를 보니 처음에 작성한것과 비슷한데.. 내가 while문을 잘 못 다루는 것 같아서 while문을 공부하고 다시 풀어야 할 것 같다.

# 은민이는 4와 7을 좋아하고, 나머지 숫자는 싫어한다. 
# 금민수는 어떤 수가 4와 7로만 이루어진 수를 말한다.
# N이 주어졌을 때, N보다 작거나 같은 금민수 중 가장 큰 것을 출력하는 프로그램을 작성하시오.

# N = int(input())

# while True:
#     for i in str(N):
#         if i =='4' and i == '7':
#             print(N)
#             break
        
#         else:
#             N -= 1


# 문제5 
# 백준 1436번 : 영화감독 숌 (https://www.acmicpc.net/problem/1436)
# 풀이를 보면 알겠는데... 이렇게 생각하기가 너무 어렵다.

# 종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. 
# 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다.
# 숌은 첫 번째 영화의 제목은 세상의 종말 666, 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다. 
# 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다.
# 숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. 

N = int(input())
number = 666                  # 제일 작은 종말의 숫자 설정
count = 0                     

while True:
    if '666' in str(number):    # while 루프안에서 number에 666 있으면 1씩 카운트하기
        count +=1
    if count == N:              # 카운트해준것과 N번째가 같을때는, number 출력하고 반복문 멈추기
        print(number)
        break
    number += 1                 # 반복문 돌릴동안 number+1