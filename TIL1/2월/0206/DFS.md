# 깊이 우선 탐색 (DFS)

## 1. 그래프 탐색 알고리즘
: 시작 정점에서 **간선을 타고 이동할 수 있는 모든 정점을 찾는** 알고리즘
- 그래프 자료구조는 **탐색 알고리즘**에 활용됨
- 그래프 탐색 알고리즘에는 깊이우선탐색과 너비우선탐색이 있음
     - 깊이우선탐색(Depth-First Search, DFS) : 그래프의 깊이를 우선으로 탐색하기 위해 **스택**의 개념을 활용
     - 너비우선탐색(Breadth-First Search, BFS) : 그래프의 너비를 우선으로 탐색하기 위해 **큐**의 개념을 활용

---

## 2. 깊이우선탐색(DFS)
### 깊이우선탐색(Depth-First Search, DFS)
: 시작 정점으로부터 **갈 수 있는 하위 정점까지 가장 깊게 탐색**하고, 더 이상 갈 곳이 없다면 마지막 갈림길로 돌아와서다른 정점을 탐색하며 결국 모든 정점을 방문하는 순회 방법
- 미로 탈출로 생각하면 이해하기 쉬움 (어느 한 쪽 길로 가장 깊게 들어갔다가 막히면 다시 돌아와서 다른 길을 탐색)

### 깊이우선탐색(DFS)의 특징
- **모든 정점을 방문**할 때 유리함
- 따라서 **경우의 수, 순열과 조합** 문제에서 많이 사용
- 너비우선탐색(BFS)에 비해 코드 구현이 간단함
- 단, 모든 정점을 방문할 필요가 없거나 최단 거리를 구하는 경우에는 너비우선탐색(BFS)이 더 유리함

---

## 3. DFS의 동작 과정
- DFS를 하기 전에, 일단 탐색을 진행할 그래프가 필요함
     - 그래프는 **인접 행렬** 혹은 **인접 리스트** 방식으로 표현할 수 있음 

- **각 정점을 방문했는지 여부를 판별할** 방문 체크 리스트가 필요함
     - visited 리스트를 따로 선언하여 각 정점을 방문했는지 체크
     ```
     visited = [False] * n  # n은 정점의 개수  

     # 인덱스는 각 정점의 번호
     # 방문한 정점은 True, 방문하지 않은 정점은 False
     ```

---

## 4. DFS의 구현 방식

### 반복문을 이용한 DFS 
```
visited = [False] * N                  # 방문 처리 리스트 만들기

def dfs(start):
    stack = [start]                    # 돌아갈 곳 기록
    visited[start] = True              # 시작 정점 방문 처리

    while stack:                       # 스텍이 빌 때까지
        cur = stack.pop                # 현재 방문 정점(스텍:후입선출)

        for adj in graph[cur]:         # 인접한 모든 정점 반복문 돌리기
            if not visited[adj]:       # 아직 방문하지 않았다면,
                visited[adj] = True    # 방문 처리하고,
                stack.append(adj)      # 스텍에 추가하기

dfs(0)                                 # 0번 정점에서 시작
```

